use profirust::dp;
use profirust::fdl;
use profirust::phy;

// Bus Parameters
const BUS_DEVICE: &'static str = "/dev/ttyUSB0";
const BAUDRATE: profirust::Baudrate = profirust::Baudrate::B500000;

fn main() {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_micros()
        .init();

    println!("ET200B Remote I/O Station Example");

    let mut dp_master = dp::DpMaster::new(vec![]);

    // Options generated by `gsdtool` using "et200b-8di8do.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "B-8DI/8DO      DP             " by "SIEMENS                       "
        ident_number: 0x000b,

        // Global Parameters:
        //   (none)
        //
        // Selected Modules:
        //   [0] 1 Byte Out, 1 Byte In
        user_parameters: Some(&[0x00, 0x00, 0x00, 0x00, 0x00]),
        config: Some(&[0x20, 0x10]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 60,
            profirust::Baudrate::B19200 => 60,
            profirust::Baudrate::B45450 => 250,
            profirust::Baudrate::B93750 => 60,
            profirust::Baudrate::B187500 => 60,
            profirust::Baudrate::B500000 => 100,
            profirust::Baudrate::B1500000 => 150,
            profirust::Baudrate::B3000000 => 250,
            profirust::Baudrate::B6000000 => 450,
            profirust::Baudrate::B12000000 => 800,
            b => panic!(
                "Peripheral \"B-8DI/8DO      DP             \" does not support baudrate {b:?}!"
            ),
        },

        fail_safe: false,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 1];
    let mut buffer_outputs = [0u8; 1];
    let mut buffer_diagnostics = [0u8; 13];
    let handle_io_siem = dp_master.add(
        dp::Peripheral::new(13, options, &mut buffer_inputs[..], &mut buffer_outputs[..])
            .with_diag_buffer(&mut buffer_diagnostics[..]),
    );

    let mut fdl = fdl::FdlActiveStation::new(
        // Address of this master, i.e. ourselves = 0x02
        fdl::ParametersBuilder::new(0x02, BAUDRATE)
            // We use a rather large T_sl time because USB-RS485 converters can induce large delays
            // at times.
            .slot_bits(4000)
            .max_retry_limit(3)
            .watchdog_timeout(profirust::time::Duration::from_secs(2))
            .build_verified(&dp_master),
    );
    // Read more about timing considerations in the SerialPortPhy documentation.
    let sleep_time = std::time::Duration::from_micros(3500);

    println!("Connecting to the bus...");
    let mut phy = phy::SerialPortPhy::new(BUS_DEVICE, fdl.parameters().baudrate);

    let start = profirust::time::Instant::now();

    fdl.set_online();
    dp_master.enter_operate();
    loop {
        let now = profirust::time::Instant::now();
        fdl.poll(now, &mut phy, &mut dp_master);

        let events = dp_master.take_last_events();

        if let Some((p, ev)) = events.peripheral {
            if ev != profirust::dp::PeripheralEvent::DataExchanged {
                log::info!("Got event for #{}: {:?}", p.address(), ev);
            }
        }

        if events.cycle_completed {
            let io = dp_master.get_mut(handle_io_siem);
            if io.is_running() {
                println!("Inputs: {:08b}", io.pi_i()[0]);

                io.pi_q_mut()[0] = if (now - start).secs() % 2 == 0 {
                    0xAA
                } else {
                    0x55
                };
            }
        }

        std::thread::sleep(sleep_time);
    }
}
