#![no_std]
#![no_main]

use bsp::hal::{self, clocks::init_clocks_and_plls, pac, sio::Sio, watchdog::Watchdog};
use rp_pico as bsp;

use embedded_hal::digital::v2::ToggleableOutputPin;
use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

use profirust::{dp, fdl, phy, Baudrate};

mod logger;
mod panic_handler;
mod time;

// Encoder Parameters
const ENCODER_ADDRESS: u8 = 6;

// Bus Parameters
const MASTER_ADDRESS: u8 = 2;
const BAUDRATE: Baudrate = Baudrate::B19200;

#[bsp::entry]
fn main() -> ! {
    logger::init();
    log::info!("Booting...");

    let mut pac = pac::Peripherals::take().unwrap();
    let _core = pac::CorePeripherals::take().unwrap();
    let mut watchdog = Watchdog::new(pac.WATCHDOG);
    let sio = Sio::new(pac.SIO);

    // External high-speed crystal on the pico board is 12Mhz
    let external_xtal_freq_hz = 12_000_000u32;
    let clocks = init_clocks_and_plls(
        external_xtal_freq_hz,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &mut pac.RESETS,
        &mut watchdog,
    )
    .ok()
    .unwrap();

    let timer = hal::Timer::new(pac.TIMER, &mut pac.RESETS, &clocks);
    // SAFETY: No interrupts are active at this point so there is no possibility of violating the
    // contract of time::init() here.
    unsafe {
        time::init(timer);
    }

    let pins = bsp::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &mut pac.RESETS,
    );

    // PICO onboard LED
    let mut led_pin = pins.led.into_push_pull_output();

    // Set up the USB driver
    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USBCTRL_REGS,
        pac.USBCTRL_DPRAM,
        clocks.usb_clock,
        true,
        &mut pac.RESETS,
    ));

    // Set up the USB Communications Class Device driver
    let mut serial = SerialPort::new(&usb_bus);

    // Create a USB device with a fake VID and PID
    let mut usb_dev = UsbDeviceBuilder::new(&usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&[StringDescriptors::default()
            .manufacturer("Rahix Automation")
            .product("PROFIRUST TEST Gadget")
            .serial_number("FOOBAR")])
        .unwrap()
        .device_class(2) // from: https://www.usb.org/defined-class-codes
        .build();

    let uart_pins = (
        // UART TX (characters sent from RP2040) on pin 1 (GPIO0)
        pins.gpio16.into_function(),
        // UART RX (characters received by RP2040) on pin 2 (GPIO1)
        pins.gpio17.into_function(),
    );
    let uart = hal::uart::UartPeripheral::new(pac.UART0, uart_pins, &mut pac.RESETS);
    let dir_pin = pins.gpio15.into_push_pull_output();
    let mut phy_buffer = [0u8; 256];
    let mut phy = phy::Rp2040Phy::new(
        uart,
        dir_pin,
        &clocks.peripheral_clock,
        &mut phy_buffer[..],
        BAUDRATE,
    )
    .unwrap();

    let mut storage: [dp::PeripheralStorage; 2] = Default::default();
    let mut dp_master = dp::DpMaster::new(&mut storage[..]);

    // Options generated by `gsdtool` using "FRAB4711.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "FRABA Encoder" by "FRABA"
        ident_number: 0x4711,

        // Global Parameters:
        //   (none)
        //
        // Selected Modules:
        //   [0] Class 1 Singleturn
        //       - Code sequence: Increasing clockwise (0)
        user_parameters: Some(&[0x00, 0x00]),
        config: Some(&[0xd0]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 60,
            profirust::Baudrate::B19200 => 60,
            profirust::Baudrate::B93750 => 60,
            profirust::Baudrate::B187500 => 60,
            profirust::Baudrate::B500000 => 100,
            b => panic!("Peripheral \"FRABA Encoder\" does not support baudrate {b:?}!"),
        },

        fail_safe: false,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 2];
    let mut buffer_outputs = [0u8; 0];
    let encoder_handle = dp_master.add(dp::Peripheral::new(
        ENCODER_ADDRESS,
        options,
        &mut buffer_inputs[..],
        &mut buffer_outputs[..],
    ));

    let mut fdl_master = fdl::FdlActiveStation::new(
        fdl::ParametersBuilder::new(MASTER_ADDRESS, BAUDRATE)
            .watchdog_timeout(profirust::time::Duration::from_secs(1))
            .slot_bits(1920)
            .build_verified(&dp_master),
    );

    let mut init = false;
    let mut last = profirust::time::Instant::ZERO;
    let mut last_value = None;
    loop {
        let now = time::now().unwrap();

        if !init && now.secs() > 1 {
            fdl_master.set_online();
            dp_master.enter_operate();
            init = true;
        }
        fdl_master.poll(now, &mut phy, &mut dp_master);

        let events = dp_master.take_last_events();

        let encoder = dp_master.get_mut(encoder_handle);
        if events.cycle_completed && encoder.is_running() {
            last_value = Some(u16::from_be_bytes(encoder.pi_i().try_into().unwrap()));
        }

        if last.secs() != now.secs() {
            if encoder.is_running() {
                log::info!("Encoder Counts: {:5}", last_value.unwrap());
            }
            let _ = led_pin.toggle();
        }

        logger::drain(|buf| match serial.write(buf) {
            Ok(n) => n,
            Err(_) => 0,
        });
        usb_dev.poll(&mut [&mut serial]);

        last = now;
    }
}
