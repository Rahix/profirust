#![no_std]
#![no_main]

use bsp::hal::{self, clocks::init_clocks_and_plls, pac, sio::Sio, watchdog::Watchdog};
use rp_pico as bsp;

use embedded_hal::digital::v2::ToggleableOutputPin;
use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

use profirust::{dp, fdl, phy, Baudrate};

mod logger;
mod panic_handler;
mod time;

// I/O Parameters
const IO_ADDRESS: u8 = 13;

// Bus Parameters
const MASTER_ADDRESS: u8 = 2;
const BAUDRATE: Baudrate = Baudrate::B500000;

#[bsp::entry]
fn main() -> ! {
    logger::init();
    log::info!("Booting...");

    let mut pac = pac::Peripherals::take().unwrap();
    let _core = pac::CorePeripherals::take().unwrap();
    let mut watchdog = Watchdog::new(pac.WATCHDOG);
    let sio = Sio::new(pac.SIO);

    // External high-speed crystal on the pico board is 12Mhz
    let external_xtal_freq_hz = 12_000_000u32;
    let clocks = init_clocks_and_plls(
        external_xtal_freq_hz,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &mut pac.RESETS,
        &mut watchdog,
    )
    .ok()
    .unwrap();

    let timer = hal::Timer::new(pac.TIMER, &mut pac.RESETS, &clocks);
    // SAFETY: No interrupts are active at this point so there is no possibility of violating the
    // contract of time::init() here.
    unsafe {
        time::init(timer);
    }

    let pins = bsp::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &mut pac.RESETS,
    );

    // PICO onboard LED
    let mut led_pin = pins.led.into_push_pull_output();

    // Set up the USB driver
    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USBCTRL_REGS,
        pac.USBCTRL_DPRAM,
        clocks.usb_clock,
        true,
        &mut pac.RESETS,
    ));

    // Set up the USB Communications Class Device driver
    let mut serial = SerialPort::new(&usb_bus);

    // Create a USB device with a fake VID and PID
    let mut usb_dev = UsbDeviceBuilder::new(&usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&[StringDescriptors::default()
            .manufacturer("Rahix Automation")
            .product("PROFIRUST TEST Gadget")
            .serial_number("FOOBAR")])
        .unwrap()
        .device_class(2) // from: https://www.usb.org/defined-class-codes
        .build();

    let uart_pins = (
        // UART TX (characters sent from RP2040) on pin 1 (GPIO0)
        pins.gpio16.into_function(),
        // UART RX (characters received by RP2040) on pin 2 (GPIO1)
        pins.gpio17.into_function(),
    );
    let uart = hal::uart::UartPeripheral::new(pac.UART0, uart_pins, &mut pac.RESETS);
    let dir_pin = pins.gpio15.into_push_pull_output();
    let mut phy_buffer = [0u8; 256];
    let mut phy = phy::Rp2040Phy::new(
        uart,
        dir_pin,
        &clocks.peripheral_clock,
        &mut phy_buffer[..],
        BAUDRATE,
    )
    .unwrap();

    let mut storage: [dp::PeripheralStorage; 2] = Default::default();
    let mut dp_master = dp::DpMaster::new(&mut storage[..]);

    // Options generated by `gsdtool` using "et200b-8di8do.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "B-8DI/8DO      DP             " by "SIEMENS                       "
        ident_number: 0x000b,

        // Global Parameters:
        //   (none)
        //
        // Selected Modules:
        //   [1] 1 Byte Out, 1 Byte In
        user_parameters: Some(&[0x00, 0x00, 0x00, 0x00, 0x00]),
        config: Some(&[0x20, 0x10]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 60,
            profirust::Baudrate::B19200 => 60,
            profirust::Baudrate::B45450 => 250,
            profirust::Baudrate::B93750 => 60,
            profirust::Baudrate::B187500 => 60,
            profirust::Baudrate::B500000 => 100,
            profirust::Baudrate::B1500000 => 150,
            profirust::Baudrate::B3000000 => 250,
            profirust::Baudrate::B6000000 => 450,
            profirust::Baudrate::B12000000 => 800,
            b => panic!(
                "Peripheral \"B-8DI/8DO      DP             \" does not support baudrate {b:?}!"
            ),
        },

        fail_safe: false,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 1];
    let mut buffer_outputs = [0u8; 1];
    let mut buffer_diagnostics = [0u8; 13];
    let io_handle = dp_master.add(
        dp::Peripheral::new(
            IO_ADDRESS,
            options,
            &mut buffer_inputs[..],
            &mut buffer_outputs[..],
        )
        .with_diag_buffer(&mut buffer_diagnostics[..]),
    );

    let mut fdl_master = fdl::FdlActiveStation::new(
        fdl::ParametersBuilder::new(MASTER_ADDRESS, BAUDRATE)
            .watchdog_timeout(profirust::time::Duration::from_secs(1))
            .slot_bits(4000)
            .max_retry_limit(3)
            .build_verified(&dp_master),
    );

    let mut init = false;
    let mut last = profirust::time::Instant::ZERO;
    loop {
        let now = time::now().unwrap();

        if !init && now.secs() > 1 {
            fdl_master.set_online();
            dp_master.enter_operate();
            init = true;
        }
        fdl_master.poll(now, &mut phy, &mut dp_master);

        let events = dp_master.take_last_events();

        let io_station = dp_master.get_mut(io_handle);
        if events.cycle_completed && io_station.is_running() {
            io_station.pi_q_mut()[0] = if now.secs() % 2 == 0 { 0x55 } else { 0xAA };
        }

        if last.secs() != now.secs() {
            if io_station.is_running() {
                log::info!("Inputs: {:08b}", io_station.pi_i()[0]);
            }
            let _ = led_pin.toggle();
        }

        logger::drain(|buf| match serial.write(buf) {
            Ok(n) => n,
            Err(_) => 0,
        });
        usb_dev.poll(&mut [&mut serial]);

        last = now;
    }
}
