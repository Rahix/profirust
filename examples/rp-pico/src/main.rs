#![no_std]
#![no_main]

use bsp::entry;
use embedded_hal::digital::v2::ToggleableOutputPin;
use panic_halt as _;

use rp_pico as bsp;

use bsp::hal::{
    self,
    clocks::init_clocks_and_plls,
    pac,
    sio::Sio,
    watchdog::Watchdog,
};

// USB Device support
use usb_device::{class_prelude::*, prelude::*};

// USB Communications Class Device support
use usbd_serial::SerialPort;

use profirust::{dp, fdl, phy, Baudrate};

mod logger;

const BAUDRATE: Baudrate = Baudrate::B19200;

#[entry]
fn main() -> ! {
    logger::init();
    log::info!("Booting...");

    let mut pac = pac::Peripherals::take().unwrap();
    let _core = pac::CorePeripherals::take().unwrap();
    let mut watchdog = Watchdog::new(pac.WATCHDOG);
    let sio = Sio::new(pac.SIO);

    // External high-speed crystal on the pico board is 12Mhz
    let external_xtal_freq_hz = 12_000_000u32;
    let clocks = init_clocks_and_plls(
        external_xtal_freq_hz,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &mut pac.RESETS,
        &mut watchdog,
    )
    .ok()
    .unwrap();

    let timer = hal::Timer::new(pac.TIMER, &mut pac.RESETS, &clocks);

    let pins = bsp::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &mut pac.RESETS,
    );

    // PICO onboard LED
    let mut led_pin = pins.led.into_push_pull_output();

    // Set up the USB driver
    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USBCTRL_REGS,
        pac.USBCTRL_DPRAM,
        clocks.usb_clock,
        true,
        &mut pac.RESETS,
    ));

    // Set up the USB Communications Class Device driver
    let mut serial = SerialPort::new(&usb_bus);

    // Create a USB device with a fake VID and PID
    let mut usb_dev = UsbDeviceBuilder::new(&usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .manufacturer("Rahix Automation")
        .product("PROFIRUST TEST Gadget")
        .serial_number("FOOBAR")
        .device_class(2) // from: https://www.usb.org/defined-class-codes
        .build();

    let uart_pins = (
        // UART TX (characters sent from RP2040) on pin 1 (GPIO0)
        pins.gpio16.into_function(),
        // UART RX (characters received by RP2040) on pin 2 (GPIO1)
        pins.gpio17.into_function(),
    );
    let uart = hal::uart::UartPeripheral::new(pac.UART0, uart_pins, &mut pac.RESETS);
    let dir_pin = pins.gpio15.into_push_pull_output();
    let mut phy_buffer = [0u8; 256];
    let mut phy = phy::Rp2040Phy::new(
        uart,
        dir_pin,
        &clocks.peripheral_clock,
        &mut phy_buffer[..],
        BAUDRATE,
    )
    .unwrap();

    let mut storage: [dp::PeripheralStorage; 2] = Default::default();
    let mut dp_master = dp::DpMaster::new(&mut storage[..]);

    // Options generated by `gsdtool` using "FRAB4711.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "FRABA Encoder" by "FRABA"
        ident_number: 0x4711,

        // Global Parameters:
        //   (none)
        //
        // Selected Modules:
        //   [0] Class 2 Singleturn
        //       - Code sequence.................: Increasing clockwise (0)
        //       - Class 2 functionality.........: Enable
        //       - Scaling function control......: Enable
        //       - Measuring units per revolution: 12
        //       - Total measuring range.........: 12
        user_parameters: Some(&[
            0x00, 0x0a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ]),
        config: Some(&[0xf0]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 60,
            profirust::Baudrate::B19200 => 60,
            profirust::Baudrate::B93750 => 60,
            profirust::Baudrate::B187500 => 60,
            profirust::Baudrate::B500000 => 100,
            b => panic!("Peripheral \"FRABA Encoder\" does not support baudrate {b:?}!"),
        },

        fail_safe: false,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 2];
    let mut buffer_outputs = [0u8; 2];
    let encoder_handle = dp_master.add(dp::Peripheral::new(
        6,
        options,
        &mut buffer_inputs,
        &mut buffer_outputs,
    ));

    let mut fdl_master = fdl::FdlMaster::new(
        fdl::ParametersBuilder::new(0x02, BAUDRATE)
            .watchdog_timeout(profirust::time::Duration::from_secs(1))
            .build_verified(&dp_master),
    );

    let mut init = false;
    let mut last = profirust::time::Instant::ZERO;
    let mut last_value = None;
    loop {
        let now = profirust::time::Instant::from_micros(i64::try_from(timer.get_counter().ticks()).unwrap());

        if !init && now.secs() > 1 {
            fdl_master.set_online();
            dp_master.enter_operate();
            init = true;
        }
        let events = fdl_master.poll(now, &mut phy, &mut dp_master);

        let encoder = dp_master.get_mut(encoder_handle);
        if events.cycle_completed && encoder.is_running() {
            last_value = Some(u16::from_be_bytes(encoder.pi_i().try_into().unwrap()));
        }

        logger::drain(|buf| match serial.write(buf) {
            Ok(n) => n,
            Err(_) => 0,
        });
        usb_dev.poll(&mut [&mut serial]);

        if last.secs() != now.secs() {
            log::info!("Encoder: {:?}!", last_value);
            let _ = led_pin.toggle();
        }
        last = now;
    }
}
