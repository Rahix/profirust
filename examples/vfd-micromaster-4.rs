use std::sync;

use profirust::dp;
use profirust::fdl;
use profirust::phy;

// VFD Parameters
const VFD_ADDRESS: u8 = 17;

// Bus Parameters
const MASTER_ADDRESS: u8 = 4;
const BUS_DEVICE: &'static str = "/dev/ttyUSB0";
const BAUDRATE: profirust::Baudrate = profirust::Baudrate::B500000;

// PROFIdrive Telegram 1
// +--------+------+---------+
// |        |    0 |       1 |
// +--------+------+---------+
// | Output | STW1 | NSOLL_A |
// +--------+------+---------+
// | Input  | ZSW1 | NIST_A  |
// +--------+------+---------+
//
// - STW1: Control Word 1
// - ZSW1: Status Word 1
// - NSOLL_A: Speed Setpoint
// - NIST_A: Speed Actual Value
process_image::process_image! {
    pub struct PiDriveControl, mut PiDriveControlMut: 4 {
        // STW1 (Control Word 1) Bits
        pub on:                     (X, 1, 0),
        pub not_off2:               (X, 1, 1),
        pub not_off3:               (X, 1, 2),
        pub enable_op:              (X, 1, 3),
        pub enable_rfg:             (X, 1, 4),
        pub resume_rfg:             (X, 1, 5),
        pub enable_setpoint:        (X, 1, 6),
        pub acknowledge_fault:      (X, 1, 7),
        pub cw_inching:             (X, 0, 0),
        pub ccw_inching:            (X, 0, 1),
        pub setpoint_valid:         (X, 0, 2),
        pub setpoint_invert:        (X, 0, 3),

        pub stw1:                   (W, 0),
        pub speed_setpoint:         (W, 2),
    }
}

process_image::process_image! {
    pub struct PiDriveStatus: 4 {
        // ZSW1 (Status Word 1) Bits
        pub ready_for_on:           (X, 1, 0),
        pub ready_to_run:           (X, 1, 1),
        pub op_enabled:             (X, 1, 2),
        pub fault_active:           (X, 1, 3),
        pub no_off2:                (X, 1, 4),
        pub no_off3:                (X, 1, 5),
        pub starting_lockout:       (X, 1, 6),
        pub alarm_active:           (X, 1, 7),
        pub no_setpoint_deviation:  (X, 0, 0),
        pub master_control:         (X, 0, 1),
        pub f_reached:              (X, 0, 2),
        pub current_ok:             (X, 0, 3),
        pub no_brake:               (X, 0, 4),
        pub no_motor_overload:      (X, 0, 5),
        pub cw_rotation:            (X, 0, 6),
        pub no_overload:            (X, 0, 7),

        pub zsw1:                   (W, 0),
        pub speed_current:          (W, 2),
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
enum VfdCommand {
    Run,
    #[default]
    Stop,
    StopCoast,
    StopFast,
    AcknowledgeFault,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
enum VfdDirection {
    #[default]
    Cw,
    Ccw,
}

#[derive(Default, Debug, Clone, PartialEq)]
struct VfdParameters {
    pub command: VfdCommand,
    pub dir: VfdDirection,
    pub status: [u8; 4],
    pub control: [u8; 4],
    pub speed_setpoint: f32,
    pub actual_speed: f32,
}

impl VfdParameters {
    pub fn control(&self) -> PiDriveControl<'_> {
        PiDriveControl::from(&self.control)
    }

    pub fn status(&self) -> PiDriveStatus<'_> {
        PiDriveStatus::from(&self.status)
    }
}

fn vfd_controller(param: sync::Arc<sync::Mutex<VfdParameters>>) {
    let mut dp_master = dp::DpMaster::new(vec![]);

    // Options generated by `gsdtool` using "si0280b5.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "MICROMASTER 4" by "Siemens AG A&D"
        ident_number: 0x80b5,

        // Global Parameters:
        //   (none)
        //
        // Selected Modules:
        //   [0] 0 PKW,  2 PZD  (PPO 3)
        user_parameters: Some(&[0x00, 0x00, 0x00]),
        config: Some(&[0x00, 0xf1]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 40,
            profirust::Baudrate::B19200 => 40,
            profirust::Baudrate::B45450 => 40,
            profirust::Baudrate::B93750 => 40,
            profirust::Baudrate::B187500 => 40,
            profirust::Baudrate::B500000 => 40,
            profirust::Baudrate::B1500000 => 40,
            profirust::Baudrate::B3000000 => 50,
            profirust::Baudrate::B6000000 => 100,
            profirust::Baudrate::B12000000 => 200,
            b => panic!("Peripheral \"MICROMASTER 4\" does not support baudrate {b:?}!"),
        },

        fail_safe: true,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 4];
    let mut buffer_outputs = [0u8; 4];
    let mut buffer_diagnostics = [0u8; 6];
    let vfd_handle = dp_master.add(
        dp::Peripheral::new(
            VFD_ADDRESS,
            options,
            &mut buffer_inputs,
            &mut buffer_outputs,
        )
        .with_diag_buffer(&mut buffer_diagnostics),
    );

    let mut fdl_master = fdl::FdlMaster::new(
        fdl::ParametersBuilder::new(MASTER_ADDRESS, BAUDRATE)
            // We use a rather large T_slot time because USB-RS485 converters
            // can induce large delays at times.
            .slot_bits(2500)
            // Make sure the VFD quickly stops when it no longer receives communication.
            //
            // The MICROMASTER 4 also includes its own watchdog mechanism via parameter
            // P2040 (Telegramm Ausfallzeit CB).
            .watchdog_timeout(profirust::time::Duration::from_millis(100))
            .build_verified(&dp_master),
    );
    // We must not poll() too often or to little. T_slot / 2 seems to be a good compromise.
    let sleep_time: std::time::Duration = (fdl_master.parameters().slot_time() / 2).into();

    log::info!("Connecting to the bus...");
    let mut phy = phy::LinuxRs485Phy::new(BUS_DEVICE, fdl_master.parameters().baudrate);

    fdl_master.set_online();
    dp_master.enter_operate();
    loop {
        let now = profirust::time::Instant::now();
        let events = fdl_master.poll(now, &mut phy, &mut dp_master);

        // Get mutable access the the peripheral here so we can interact with it.
        let vfd = dp_master.get_mut(vfd_handle);

        if let Some((handle, event)) = &events.peripheral {
            if *handle == vfd_handle && *event == dp::PeripheralEvent::Diagnostics {
                log::warn!(
                    "VFD Diagnostics: {:?}",
                    vfd.last_diagnostics().unwrap().extended_diagnostics
                );
            }
        }

        if vfd.is_running() && events.cycle_completed {
            let mut param = param.lock().unwrap();
            param.status.copy_from_slice(vfd.pi_i());
            param.actual_speed = f32::from(param.status().speed_current()) / 16384.0;

            let mut control_buf = [0; 4];
            let mut control = PiDriveControlMut::from(&mut control_buf);
            *control.on() = param.command == VfdCommand::Run;
            *control.not_off2() = param.command != VfdCommand::StopCoast;
            *control.not_off3() = param.command != VfdCommand::StopFast;
            *control.enable_op() = true;
            *control.enable_rfg() = true;
            *control.resume_rfg() = true;
            *control.enable_setpoint() = true;
            *control.acknowledge_fault() = param.command == VfdCommand::AcknowledgeFault;
            *control.setpoint_valid() = true;
            *control.setpoint_invert() = param.dir == VfdDirection::Ccw;

            let speed = ((param.speed_setpoint * 16384.0) as u16).min(16384);
            *control.speed_setpoint() = speed;

            param.control.copy_from_slice(&control_buf);
            vfd.pi_q_mut().copy_from_slice(&control_buf);
        }

        std::thread::sleep(sleep_time);
    }
}

#[derive(Clone, Debug, Default)]
struct LogBuffer {
    buffer: sync::Arc<sync::Mutex<std::collections::VecDeque<u8>>>,
    condvar: sync::Arc<sync::Condvar>,
}

impl std::io::Write for LogBuffer {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        let res = self.buffer.lock().unwrap().write(buf);
        self.condvar.notify_one();
        res
    }

    fn flush(&mut self) -> std::io::Result<()> {
        Ok(())
    }
}

impl std::io::Read for LogBuffer {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let mut log_buffer = self.buffer.lock().unwrap();
        if let Ok(s) = log_buffer.read(buf) {
            return Ok(s);
        }
        let mut log_buffer = self.condvar.wait(log_buffer).unwrap();
        log_buffer.read(buf)
    }
}

fn main() {
    let log_buffer = LogBuffer::default();
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_micros()
        .target(env_logger::Target::Pipe(Box::new(log_buffer.clone())))
        .init();

    let mut rl = rustyline::DefaultEditor::new().unwrap();
    let mut printer = rl.create_external_printer().unwrap();

    std::thread::spawn(move || {
        use rustyline::ExternalPrinter;
        use std::io::BufRead;

        let mut log_buffer_reader = std::io::BufReader::new(log_buffer);
        loop {
            let mut buffer = String::new();
            if let Ok(l) = log_buffer_reader.read_line(&mut buffer) {
                if l > 0 {
                    printer.print(buffer).unwrap();
                }
            }
        }
    });

    log::info!("MICROMASTER 4 Variable Frequency Drive");
    log::info!("======================================");
    log::info!("Interactive command prompt.  Type \"help\" for a list of commands.");

    let vfd_parameters: sync::Arc<sync::Mutex<VfdParameters>> = Default::default();

    vfd_parameters.lock().unwrap().speed_setpoint = 1.0;

    let bus_thread = std::thread::spawn({
        let vfd_parameters = vfd_parameters.clone();
        move || {
            vfd_controller(vfd_parameters);
        }
    });

    'repl: while let Ok(line) = rl.readline("profirust vfd> ") {
        if !line.is_empty() {
            rl.add_history_entry(line.as_str()).unwrap();

            match line.trim() {
                "start" => {
                    eprintln!("Switching to RUNNING state.");
                    vfd_parameters.lock().unwrap().command = VfdCommand::Run;
                }
                "stop" => {
                    eprintln!("Switching to OFF1.");
                    vfd_parameters.lock().unwrap().command = VfdCommand::Stop;
                }
                "ack" => {
                    eprintln!("Faults acknowledged.");
                    vfd_parameters.lock().unwrap().command = VfdCommand::AcknowledgeFault;
                }
                "cw" => {
                    eprintln!("Direction: Clockwise");
                    vfd_parameters.lock().unwrap().dir = VfdDirection::Cw;
                }
                "ccw" => {
                    eprintln!("Direction: Counterclockwise");
                    vfd_parameters.lock().unwrap().dir = VfdDirection::Ccw;
                }
                "rev" => {
                    let dir = &mut vfd_parameters.lock().unwrap().dir;
                    *dir = match *dir {
                        VfdDirection::Cw => {
                            eprintln!("Direction: Counterclockwise");
                            VfdDirection::Ccw
                        }
                        VfdDirection::Ccw => {
                            eprintln!("Direction: Clockwise");
                            VfdDirection::Cw
                        }
                    };
                }
                "dump" => {
                    println!("{:#?}", vfd_parameters.lock().unwrap().control());
                    println!("{:#?}", vfd_parameters.lock().unwrap().status());
                }
                "help" => {
                    eprintln!("Commands:");
                    eprintln!("  start   - Start motor if possible.");
                    eprintln!("  stop    - Stop motor via OFF1.");
                    eprintln!("  ack     - Acknowledge drive faults.");
                    eprintln!("  cw      - Set direction clockwise.");
                    eprintln!("  ccw     - Set direction counterclockwise.");
                    eprintln!("  rev     - Reverse motor direction.");
                    eprintln!("  dump    - Show all drive control and status information.");
                    eprintln!("  <speed> - Set speed setpoint as a number between 0-100.");
                    eprintln!("  quit    - Exit. Consider using `stop` before exiting.");
                }
                "quit" | "exit" => {
                    break 'repl;
                }
                other => {
                    if let Ok(speed) = other.parse::<u8>() {
                        if speed > 100 {
                            eprintln!("Speed {speed} too high!");
                        } else {
                            eprintln!("Speed setpoint {speed:3}%.");
                            vfd_parameters.lock().unwrap().speed_setpoint =
                                f32::from(speed) / 100.0;
                        }
                    } else {
                        eprintln!("Unknown command {other:?}");
                    }
                }
            }
        }

        if bus_thread.is_finished() {
            break 'repl;
        }
    }

    println!("Exiting...");
    if bus_thread.is_finished() {
        bus_thread.join().unwrap();
    }
}
